import { InstructionKey } from "./type";


export const INSTRUCTION_DETAILS_TC: Array<{ name: InstructionKey, content: string }> = [
    {
        name: "ADDLW",
        content: `#### ADDLW
將常數與 W 相加

|||
|---|---|
| 語法:          | \`ADDLW k\` |
| 運算元:        | 0 ≤ k ≤ 255 |
| 操作:          | (W) + k → W |
| 受影響狀態位元: | N, OV, C, DC, Z |
| 編碼:          | 0000 1111 kkkk kkkk |

**描述:** W 的內容與 8 位元常數 'k' 相加，結果存入 W。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'k' | 處理資料 | 寫入 W |

**範例:**
\`\`\`
ADDLW 15h
\`\`\`

指令執行前  
W = 10h  
指令執行後  
W = 25h`
    },
    {
        name: "ADDWF",
        content: `#### ADDWF
將 W 與 f 相加

|||
|---|---|
| 語法:          | \`ADDWF f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (W) + (f) → dest |
| 受影響狀態位元: | N, OV, C, DC, Z |
| 編碼:          | 0001 11da ffff ffff |

**描述:** 將 W 暫存器的內容與暫存器 'f' 相加。如果 'd' 為 '0'，結果儲存在 W 暫存器。如果 'd' 為 '1'，結果存回暫存器 'f' (預設值)。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入目的地 |

**範例:**
\`\`\`
ADDWF REG, 0, 0
\`\`\`

指令執行前  
W = 17h  
REG = 0C2h  
指令執行後  
W = D9h  
REG = 0C2h`
    },
    {
        name: "ADDWFC",
        content: `#### ADDWFC
將 W 與進位位元加到 f

|||
|---|---|
| 語法:          | \`ADDWFC f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (W) + (f) + (C) → dest |
| 受影響狀態位元: | N, OV, C, DC, Z |
| 編碼:          | 0010 00da ffff ffff |

**描述:** 將 W、進位旗標 (Carry flag) 和資料記憶體位置 "f" 相加。如果 'd' 為 '0'，結果置於 W。如果 'd' 為 '1'，結果置於資料記憶體位置 "f"。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 "f" | 處理資料 | 寫入目的地 |

**範例:**
\`\`\`
ADDWFC REG, 0, 1
\`\`\`

指令執行前  
進位位元 = 1  
REG = 02h  
W = 40h  
指令執行後  
進位位元 = 0  
REG = 02h  
W = 50h`
    },
    {
        name: "ANDLW",
        content: `#### ANDLW
將常數與 W 進行 AND 運算

|||
|---|---|
| 語法:          | \`ANDLW k\` |
| 運算元:        | 0 ≤ k ≤ 255 |
| 操作:          | (W) .AND. k → W |
| 受影響狀態位元: | N, Z |
| 編碼:          | 0000 1011 kkkk kkkk |

**描述:** W 的內容與 8 位元常數 'k' 進行 AND 運算。結果置於 W。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'k' | 處理資料 | 寫入 W |

**範例:**
\`\`\`
ANDLW 5Fh
\`\`\`

指令執行前  
W = A3h  
指令執行後  
W = 03h`
    },
    {
        name: "ANDWF",
        content: `#### ANDWF
將 W 與 f 進行 AND 運算

|||
|---|---|
| 語法:          | \`ANDWF f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (W) .AND. (f) → dest |
| 受影響狀態位元: | N, Z |
| 編碼:          | 0001 01da ffff ffff |

**描述:** W 的內容與暫存器 "f" 進行 AND 運算。如果 'd' 為 '0'，結果儲存在 W。如果 'd' 為 '1'，結果存回暫存器 "f" (預設值)。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 "f" | 處理資料 | 寫入目的地 |

**範例:**
\`\`\`
ANDWF REG, 0, 0
\`\`\`

指令執行前  
W = 17h  
REG = C2h  
指令執行後  
W = 02h  
REG = C2h`
    },
    {
        name: "BC",
        content: `#### BC
若進位則分支 (Branch if Carry)

|||
|---|---|
| 語法:          | \`BC n\` |
| 運算元:        | -128 ≤ n ≤ 127 |
| 操作:          | 若進位位元為 '1', (PC) + 2 + 2n → PC |
| 受影響狀態位元: | 無 |
| 編碼:          | 1110 0010 nnnn nnnn |

**描述:** 如果進位位元 (Carry bit) 為 '1'，則程式將分支。將 2 的補數 '2n' 加到 PC。由於 PC 會遞增以取得下一個指令，新位址將是 PC + 2 + 2n。此指令因此成為一個兩週期指令。

**字數:** 1  
**週期數:** 1(2)  

**Q 週期活動:**
若跳躍:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'n' | 處理資料 | 寫入 PC |
| 無操作 | 無操作 | 無操作 | 無操作 |

若不跳躍:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'n' | 處理資料 | 無操作 |

**範例:**
\`\`\`
(HERE) BC 5
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
若進位 = 1; PC = 位址 (HERE + 12)  
若進位 = 0; PC = 位址 (HERE + 2)`
    },
    {
        name: "BCF",
        content: `#### BCF
清除 f 的位元 (Bit Clear f)

|||
|---|---|
| 語法:          | \`BCF f, b {,a}\` |
| 運算元:        | 0 ≤ f ≤ 255 0 ≤ b ≤ 7 a ∈ [0,1] |
| 操作:          | 0 → f<b> |
| 受影響狀態位元: | 無 |
| 編碼:          | 1001 bbba ffff ffff |

**描述:** 清除暫存器 'f' 中的位元 'b'。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入暫存器 'f' |

**範例:**
\`\`\`
BCF FLAG_REG, 7, 0
\`\`\`

指令執行前  
FLAG_REG = C7h  
指令執行後  
FLAG_REG = 47h`
    },
    {
        name: "BN",
        content: `#### BN
若負則分支 (Branch if Negative)

|||
|---|---|
| 語法:          | \`BN n\` |
| 運算元:        | -128 ≤ n ≤ 127 |
| 操作:          | 若負位元 (Negative bit) 為 '1', (PC) + 2 + 2n → PC |
| 受影響狀態位元: | 無 |
| 編碼:          | 1110 0110 nnnn nnnn |

**描述:** 如果負位元 (Negative bit) 為 '1'，則程式將分支。將 2 的補數 '2n' 加到 PC。由於 PC 會遞增以取得下一個指令，新位址將是 PC + 2 + 2n。此指令因此成為一個兩週期指令。

**字數:** 1  
**週期數:** 1(2)  

**Q 週期活動:**
若跳躍:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'n' | 處理資料 | 寫入 PC |
| 無操作 | 無操作 | 無操作 | 無操作 |

若不跳躍:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'n' | 處理資料 | 無操作 |

**範例:**
\`\`\`
(HERE) BN Jump
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
若負 = 1; PC = 位址 (Jump)  
若負 = 0; PC = 位址 (HERE + 2)`
    },
    {
        name: "BNC",
        content: `#### BNC
若無進位則分支 (Branch if Not Carry)

|||
|---|---|
| 語法:          | \`BNC n\` |
| 運算元:        | -128 ≤ n ≤ 127 |
| 操作:          | 若進位位元為 '0', (PC) + 2 + 2n → PC |
| 受影響狀態位元: | 無 |
| 編碼:          | 1110 0011 nnnn nnnn |

**描述:** 如果進位位元 (Carry bit) 為 '0'，則程式將分支。將 2 的補數 '2n' 加到 PC。由於 PC 會遞增以取得下一個指令，新位址將是 PC + 2 + 2n。此指令因此成為一個兩週期指令。

**字數:** 1  
**週期數:** 1(2)  

**Q 週期活動:**
若跳躍:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'n' | 處理資料 | 寫入 PC |
| 無操作 | 無操作 | 無操作 | 無操作 |

若不跳躍:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'n' | 處理資料 | 無操作 |

**範例:**
\`\`\`
(HERE) BNC Jump
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
若進位 = 0; PC = 位址 (Jump)  
若進位 = 1; PC = 位址 (HERE + 2)`
    },
    {
        name: "BNN",
        content: `#### BNN
若非負則分支 (Branch if Not Negative)

|||
|---|---|
| 語法:          | \`BNN n\` |
| 運算元:        | -128 ≤ n ≤ 127 |
| 操作:          | 若負位元為 '0', (PC) + 2 + 2n → PC |
| 受影響狀態位元: | 無 |
| 編碼:          | 1110 0111 nnnn nnnn |

**描述:** 如果負位元 (Negative bit) 為 '0'，則程式將分支。將 2 的補數 '2n' 加到 PC。由於 PC 會遞增以取得下一個指令，新位址將是 PC + 2 + 2n。此指令因此成為一個兩週期指令。

**字數:** 1  
**週期數:** 1(2)  

**Q 週期活動:**
若跳躍:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'n' | 處理資料 | 寫入 PC |
| 無操作 | 無操作 | 無操作 | 無操作 |

若不跳躍:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'n' | 處理資料 | 無操作 |

**範例:**
\`\`\`
(HERE) BNN Jump
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
若負 = 0; PC = 位址 (Jump)  
若負 = 1; PC = 位址 (HERE + 2)`
    },
    {
        name: "BNOV",
        content: `#### BNOV
若無溢位則分支 (Branch if Not Overflow)

|||
|---|---|
| 語法:          | \`BNOV n\` |
| 運算元:        | -128 ≤ n ≤ 127 |
| 操作:          | 若溢位位元 (Overflow bit) 為 '0', (PC) + 2 + 2n → PC |
| 受影響狀態位元: | 無 |
| 編碼:          | 1110 0101 nnnn nnnn |

**描述:** 如果溢位位元 (Overflow bit) 為 '0'，則程式將分支。將 2 的補數 '2n' 加到 PC。由於 PC 會遞增以取得下一個指令，新位址將是 PC + 2 + 2n。此指令因此成為一個兩週期指令。

**字數:** 1  
**週期數:** 1(2)  

**Q 週期活動:**
若跳躍:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'n' | 處理資料 | 寫入 PC |
| 無操作 | 無操作 | 無操作 | 無操作 |

若不跳躍:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'n' | 處理資料 | 無操作 |

**範例:**
\`\`\`
(HERE) BNOV Jump
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
若溢位 = 0; PC = 位址 (Jump)  
若溢位 = 1; PC = 位址 (HERE + 2)`
    },
    {
        name: "BNZ",
        content: `#### BNZ
若非零則分支 (Branch if Not Zero)

|||
|---|---|
| 語法:          | \`BNZ n\` |
| 運算元:        | -128 ≤ n ≤ 127 |
| 操作:          | 若零位元 (Zero bit) 為 '0', (PC) + 2 + 2n → PC |
| 受影響狀態位元: | 無 |
| 編碼:          | 1110 0001 nnnn nnnn |

**描述:** 如果零位元 (Zero bit) 為 '0'，則程式將分支。將 2 的補數 '2n' 加到 PC。由於 PC 會遞增以取得下一個指令，新位址將是 PC + 2 + 2n。此指令因此成為一個兩週期指令。

**字數:** 1  
**週期數:** 1(2)  

**Q 週期活動:**
若跳躍:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'n' | 處理資料 | 寫入 PC |
| 無操作 | 無操作 | 無操作 | 無操作 |

若不跳躍:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'n' | 處理資料 | 無操作 |

**範例:**
\`\`\`
(HERE) BNZ Jump
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
若零 = 0; PC = 位址 (Jump)  
若零 = 1; PC = 位址 (HERE + 2)`
    },
    {
        name: "BRA",
        content: `#### BRA
無條件分支 (Unconditional Branch)

|||
|---|---|
| 語法:          | \`BRA n\` |
| 運算元:        | -1024 ≤ n ≤ 1023 |
| 操作:          | (PC) + 2 + 2n → PC |
| 受影響狀態位元: | 無 |
| 編碼:          | 1101 0nnn nnnn nnnn |

**描述:** 將 2 的補數 '2n' 加到 PC。由於 PC 會遞增以取得下一個指令，新位址將是 PC + 2 + 2n。此指令是一個兩週期指令。

**字數:** 1  
**週期數:** 2  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'n' | 處理資料 | 寫入 PC |
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
(HERE) BRA Jump
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
PC = 位址 (Jump)`
    },
    {
        name: "BSF",
        content: `#### BSF
設定 f 的位元 (Bit Set f)

|||
|---|---|
| 語法:          | \`BSF f, b {,a}\` |
| 運算元:        | 0 ≤ f ≤ 255 0 ≤ b ≤ 7 a ∈ [0,1] |
| 操作:          | 1 → f<b> |
| 受影響狀態位元: | 無 |
| 編碼:          | 1000 bbba ffff ffff |

**描述:** 設定暫存器 'f' 中的位元 'b'。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入暫存器 'f' |

**範例:**
\`\`\`
BSF FLAG_REG, 7, 1
\`\`\`

指令執行前  
FLAG_REG = 0Ah  
指令執行後  
FLAG_REG = 8Ah`
    },
    {
        name: "BTFSC",
        content: `#### BTFSC
測試檔案位元，若清除則跳過 (Bit Test File, Skip if Clear)

|||
|---|---|
| 語法:          | \`BTFSC f, b {,a}\` |
| 運算元:        | 0 ≤ f ≤ 255 0 ≤ b ≤ 7 a ∈ [0,1] |
| 操作:          | 若 (f<b>) = 0 則跳過 |
| 受影響狀態位元: | 無 |
| 編碼:          | 1011 bbba ffff ffff |

**描述:** 如果暫存器 'f' 中的位元 'b' 為 '0'，則跳過下一個指令。如果位元 'b' 為 '0'，則在當前指令執行期間取得的下一條指令將被丟棄，並改為執行 NOP，從而使此指令成為兩週期指令。

**字數:** 1  
**週期數:** 1(2)  
**注意:** 若跳過且後面是 2 字指令，則為 3 週期。

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 無操作 |

若跳過:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
(HERE) BTFSC FLAG, 1  
FALSE :  
TRUE :  
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
若 FLAG<1> = 0; PC = 位址 (TRUE)  
若 FLAG<1> = 1; PC = 位址 (FALSE)`
    },
    {
        name: "BTFSS",
        content: `#### BTFSS
測試檔案位元，若設定則跳過 (Bit Test File, Skip if Set)

|||
|---|---|
| 語法:          | \`BTFSS f, b {,a}\` |
| 運算元:        | 0 ≤ f ≤ 255 0 ≤ b ≤ 7 a ∈ [0,1] |
| 操作:          | 若 (f<b>) = 1 則跳過 |
| 受影響狀態位元: | 無 |
| 編碼:          | 1010 bbba ffff ffff |

**描述:** 如果暫存器 'f' 中的位元 'b' 為 '1'，則跳過下一個指令。如果位元 'b' 為 '1'，則在當前指令執行期間取得的下一條指令將被丟棄，並改為執行 NOP，從而使此指令成為兩週期指令。

**字數:** 1  
**週期數:** 1(2)  
**注意:** 若跳過且後面是 2 字指令，則為 3 週期。

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 無操作 |

若跳過:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
(HERE) BTFSS FLAG, 1  
FALSE :  
TRUE :  
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
若 FLAG<1> = 1; PC = 位址 (FALSE)  
若 FLAG<1> = 0; PC = 位址 (TRUE)`
    },
    {
        name: "BTG",
        content: `#### BTG
切換 f 的位元 (Bit Toggle f)

|||
|---|---|
| 語法:          | \`BTG f, b {,a}\` |
| 運算元:        | 0 ≤ f ≤ 255 0 ≤ b ≤ 7 a ∈ [0,1] |
| 操作:          | (f<b>) → f<b> |
| 受影響狀態位元: | 無 |
| 編碼:          | 0111 bbba ffff ffff |

**描述:** 反轉資料記憶體位置 'f' 中的位元 'b'。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入暫存器 'f' |

**範例:**
\`\`\`
BTG PORTC, 4, 0
\`\`\`

指令執行前:  
PORTC = 0111 0101 [75h]  
指令執行後:  
PORTC = 0110 0101 [65h]`
    },
    {
        name: "BOV",
        content: `#### BOV
若溢位則分支 (Branch if Overflow)

|||
|---|---|
| 語法:          | \`BOV n\` |
| 運算元:        | -128 ≤ n ≤ 127 |
| 操作:          | 若溢位位元為 '1', (PC) + 2 + 2n → PC |
| 受影響狀態位元: | 無 |
| 編碼:          | 1110 0100 nnnn nnnn |

**描述:** 如果溢位位元 (Overflow bit) 為 '1'，則程式將分支。將 2 的補數 '2n' 加到 PC。由於 PC 會遞增以取得下一個指令，新位址將是 PC + 2 + 2n。此指令因此成為一個兩週期指令。

**字數:** 1  
**週期數:** 1(2)  

**Q 週期活動:**
若跳躍:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'n' | 處理資料 | 寫入 PC |
| 無操作 | 無操作 | 無操作 | 無操作 |

若不跳躍:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'n' | 處理資料 | 無操作 |

**範例:**
\`\`\`
(HERE) BOV Jump
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
若溢位 = 1; PC = 位址 (Jump)  
若溢位 = 0; PC = 位址 (HERE + 2)`
    },
    {
        name: "BZ",
        content: `#### BZ
若零則分支 (Branch if Zero)

|||
|---|---|
| 語法:          | \`BZ n\` |
| 運算元:        | -128 ≤ n ≤ 127 |
| 操作:          | 若零位元為 '1', (PC) + 2 + 2n → PC |
| 受影響狀態位元: | 無 |
| 編碼:          | 1110 0000 nnnn nnnn |

**描述:** 如果零位元 (Zero bit) 為 '1'，則程式將分支。將 2 的補數 '2n' 加到 PC。由於 PC 會遞增以取得下一個指令，新位址將是 PC + 2 + 2n。此指令因此成為一個兩週期指令。

**字數:** 1  
**週期數:** 1(2)  

**Q 週期活動:**
若跳躍:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'n' | 處理資料 | 寫入 PC |
| 無操作 | 無操作 | 無操作 | 無操作 |

若不跳躍:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'n' | 處理資料 | 無操作 |

**範例:**
\`\`\`
(HERE) BZ Jump
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
若零 = 1; PC = 位址 (Jump)  
若零 = 0; PC = 位址 (HERE + 2)`
    },
    {
        name: "CALL",
        content: `#### CALL
副程式呼叫 (Subroutine Call)

|||
|---|---|
| 語法:          | \`CALL k {,s}\` |
| 運算元:        | 0 ≤ k ≤ 1048575 s ∈ [0,1] |
| 操作:          | (PC) + 4 → TOS, k → PC<20:1>; 若 s = 1, (W) → WS, (STATUS) → STATUSS, (BSR) → BSRS |
| 受影響狀態位元: | 無 |
| 編碼:          | 第 1 字: 1110 1111 110s kkkk<br>第 2 字: kkkk kkkk kkkk kkkk |

**描述:** 在整個 2 Mbyte 記憶體範圍內的副程式呼叫。首先，返回位址 (PC + 4) 被推入返回堆疊。如果 's' = 1，則 W、STATUS 和 BSR 暫存器也會被推入它們各自的影子暫存器 WS、STATUSS 和 BSRS。如果 's' = 0，則不進行更新 (預設值)。然後，將 20 位元值 'k' 載入 PC<20:1>。CALL 是一個兩週期指令。

**字數:** 2  
**週期數:** 2  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'k'<7:0>, 將 PC 推入堆疊 | 讀取常數 'k'<19:8>, 寫入 PC | 無操作 |
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
(HERE) CALL THERE, 1
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
PC = 位址 (THERE)  
TOS = 位址 (HERE + 4)  
WS = W  
BSRS = BSR  
STATUSS = STATUS`
    },
    {
        name: "CLRF",
        content: `#### CLRF
清除 f (Clear f)

|||
|---|---|
| 語法:          | \`CLRF f {,a}\` |
| 運算元:        | 0 ≤ f ≤ 255 a ∈ [0,1] |
| 操作:          | 000h → f, 1 → Z |
| 受影響狀態位元: | Z |
| 編碼:          | 0110 101a ffff ffff |

**描述:** 清除指定暫存器的內容。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入暫存器 'f' |

**範例:**
\`\`\`
CLRF FLAG_REG, 1
\`\`\`

指令執行前  
FLAG_REG = 5Ah  
指令執行後  
FLAG_REG = 00h`
    },
    {
        name: "CLRWDT",
        content: `#### CLRWDT
清除看門狗計時器 (Clear Watchdog Timer)

|||
|---|---|
| 語法:          | \`CLRWDT\` |
| 運算元:        | 無 |
| 操作:          | 000h → WDT, 000h → WDT 後分頻器, 1 → TO, 1 → PD |
| 受影響狀態位元: | TO, PD |
| 編碼:          | 0000 0000 0000 0100 |

**描述:** CLRWDT 指令重設看門狗計時器 (Watchdog Timer)。它也會重設 WDT 的後分頻器 (post-scaler)。狀態位元 TO 和 PD 被設定。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 無操作 | 處理資料 | 無操作 |

**範例:**
\`\`\`
CLRWDT
\`\`\`

指令執行前  
WDT 計數器 = ?  
指令執行後  
WDT 計數器 = 00h  
WDT 後分頻器 = 0  
TO = 1  
PD = 1`
    },
    {
        name: "COMF",
        content: `#### COMF
對 f 取補數 (Complement f)

|||
|---|---|
| 語法:          | \`COMF f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (f) → dest |
| 受影響狀態位元: | N, Z |
| 編碼:          | 0001 00da ffff ffff |

**描述:** 暫存器 'f' 的內容被取補數 (1 的補數)。如果 'd' 為 '0'，結果儲存在 W。如果 'd' 為 '1'，結果存回暫存器 'f' (預設值)。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入目的地 |

**範例:**
\`\`\`
COMF REG, 0, 0
\`\`\`

指令執行前  
REG = 13h  
指令執行後  
REG = 13h  
W = ECh`
    },
    {
        name: "CPFSEQ",
        content: `#### CPFSEQ
比較 f 與 W，若相等則跳過 (Compare f with W, Skip if Equal)

|||
|---|---|
| 語法:          | \`CPFSEQ f {,a}\` |
| 運算元:        | 0 ≤ f ≤ 255 a ∈ [0,1] |
| 操作:          | (f) - (W), 若 (f) = (W) 則跳過 |
| 受影響狀態位元: | 無 |
| 編碼:          | 0110 001a ffff ffff |

**描述:** 比較資料記憶體位置 'f' 的內容與 W 暫存器。如果 'f' = W，則跳過下一條指令。如果 'f' = W，則在當前指令執行期間取得的下一條指令將被丟棄，並改為執行 NOP，從而使此指令成為兩週期指令。

**字數:** 1  
**週期數:** 1(2)  
**注意:** 若跳過且後面是 2 字指令，則為 3 週期。

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 無操作 |

若跳過:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
(HERE) CPFSEQ REG, 1  
FALSE :  
TRUE :  
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
若 REG = W; PC = 位址 (TRUE)  
若 REG ≠ W; PC = 位址 (FALSE)`
    },
    {
        name: "CPFSGT",
        content: `#### CPFSGT
比較 f 與 W，若大於則跳過 (Compare f with W, Skip if Greater)

|||
|---|---|
| 語法:          | \`CPFSGT f {,a}\` |
| 運算元:        | 0 ≤ f ≤ 255 a ∈ [0,1] |
| 操作:          | (f) - (W), 若 (f) > (W) 則跳過 |
| 受影響狀態位元: | 無 |
| 編碼:          | 0110 010a ffff ffff |

**描述:** 比較資料記憶體位置 'f' 的內容與 W 暫存器。如果 'f' > W，則跳過下一條指令。如果 'f' > W，則在當前指令執行期間取得的下一條指令將被丟棄，並改為執行 NOP，從而使此指令成為兩週期指令。

**字數:** 1  
**週期數:** 1(2)  
**注意:** 若跳過且後面是 2 字指令，則為 3 週期。

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 無操作 |

若跳躍:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
(HERE) CPFSGT REG, 1  
FALSE :  
TRUE :  
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
若 REG > W; PC = 位址 (TRUE)  
若 REG ≤ W; PC = 位址 (FALSE)`
    },
    {
        name: "CPFSLT",
        content: `#### CPFSLT
比較 f 與 W，若小於則跳過 (Compare f with W, Skip if Less)

|||
|---|---|
| 語法:          | \`CPFSLT f {,a}\` |
| 運算元:        | 0 ≤ f ≤ 255 a ∈ [0,1] |
| 操作:          | (f) - (W), 若 (f) < (W) 則跳過 |
| 受影響狀態位元: | 無 |
| 編碼:          | 0110 000a ffff ffff |

**描述:** 比較資料記憶體位置 'f' 的內容與 W 暫存器。如果 'f' < W，則跳過下一條指令。如果 'f' < W，則在當前指令執行期間取得的下一條指令將被丟棄，並改為執行 NOP，從而使此指令成為兩週期指令。

**字數:** 1  
**週期數:** 1(2)  
**注意:** 若跳過且後面是 2 字指令，則為 3 週期。

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 無操作 |

若跳過:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
(HERE) CPFSLT REG, 1  
FALSE :  
TRUE :  
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
若 REG < W; PC = 位址 (TRUE)  
若 REG ≥ W; PC = 位址 (FALSE)`
    },
    {
        name: "DAW",
        content: `#### DAW
十進制調整 W (Decimal Adjust W)

|||
|---|---|
| 語法:          | \`DAW\` |
| 運算元:        | 無 |
| 操作:          | 調整 W 以產生十進制加法結果 |
| 受影響狀態位元: | C |
| 編碼:          | 0000 0000 0000 0111 |

**描述:** DAW 指令根據半進位 (Digit Carry, DC) 和進位 (Carry, C) 位元的狀態，調整 W 暫存器中 8 位元資料的內容，該資料是兩個二進制編碼十進制 (Binary-Coded Decimal, BCD) 數字相加的結果。詳細操作請參閱資料手冊的架構章節。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 無操作 | 處理資料 | 寫入 W |

**範例:**
\`\`\`
DAW
\`\`\`

指令執行前  
W = A5h  
指令執行後  
W = 05h  
C = 1`
    },
    {
        name: "DCFSNZ",
        content: `#### DCFSNZ
f 遞減，若不為零則跳過 (Decrement f, Skip if Not Zero)

|||
|---|---|
| 語法:          | \`DCFSNZ f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (f) - 1 → dest, 若 (f) - 1 ≠ 0 則跳過 |
| 受影響狀態位元: | 無 |
| 編碼:          | 0010 11da ffff ffff |

**描述:** 暫存器 'f' 的內容遞減 1。如果 'd' 為 '0'，結果儲存在 W。如果 'd' 為 '1'，結果存回暫存器 'f' (預設值)。如果結果不為 0，則跳過下一條指令。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1(2)  
**注意:** 若跳過且後面是 2 字指令，則為 3 週期。

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入目的地 |

若跳過:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
(HERE) DCFSNZ CNT, 1, 1  
CONT_A :  
CONT_B :  
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
若 CNT - 1 = 0; PC = 位址 (CONT_A)  
若 CNT - 1 ≠ 0; PC = 位址 (CONT_B)`
    },
    {
        name: "DECF",
        content: `#### DECF
f 遞減 (Decrement f)

|||
|---|---|
| 語法:          | \`DECF f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (f) - 1 → dest |
| 受影響狀態位元: | N, OV, Z |
| 編碼:          | 0000 01da ffff ffff |

**描述:** 暫存器 'f' 的內容遞減 1。如果 'd' 為 '0'，結果儲存在 W。如果 'd' 為 '1'，結果存回暫存器 'f' (預設值)。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入目的地 |

**範例:**
\`\`\`
DECF CNT, 1, 1
\`\`\`

指令執行前  
CNT = 01h  
指令執行後  
CNT = 00h`
    },
    {
        name: "DECFSZ",
        content: `#### DECFSZ
f 遞減，若為零則跳過 (Decrement f, Skip if Zero)

|||
|---|---|
| 語法:          | \`DECFSZ f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (f) - 1 → dest, 若 (f) - 1 = 0 則跳過 |
| 受影響狀態位元: | 無 |
| 編碼:          | 0010 10da ffff ffff |

**描述:** 暫存器 'f' 的內容遞減 1。如果 'd' 為 '0'，結果儲存在 W。如果 'd' 為 '1'，結果存回暫存器 'f' (預設值)。如果結果為 0，則跳過下一條指令。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1(2)  
**注意:** 若跳過且後面是 2 字指令，則為 3 週期。

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入目的地 |

若跳過:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
(HERE) DECFSZ CNT, 1, 1  
CONT_A :  
CONT_B :  
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
若 CNT - 1 = 0; PC = 位址 (CONT_A)  
若 CNT - 1 ≠ 0; PC = 位址 (CONT_B)`
    },
    {
        name: "GOTO",
        content: `#### GOTO
無條件跳躍 (Unconditional Branch)

|||
|---|---|
| 語法:          | \`GOTO k\` |
| 運算元:        | 0 ≤ k ≤ 1048575 |
| 操作:          | k → PC<20:1> |
| 受影響狀態位元: | 無 |
| 編碼:          | 第 1 字: 1110 1111 kkkk kkkk<br>第 2 字: kkkk kkkk kkkk kkkk |

**描述:** GOTO 是一個無條件跳躍指令，可以跳至整個 2 Mbyte 程式記憶體空間的任何位址。載入 PC 的 20 位元值 'k' 來自於 GOTO 指令編碼中的 20 個位元。GOTO 總是一個兩週期指令。

**字數:** 2  
**週期數:** 2  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'k'<7:0> | 讀取常數 'k'<19:8>, 寫入 PC | 無操作 |
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
GOTO THERE
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
PC = 位址 (THERE)`
    },
    {
        name: "INCF",
        content: `#### INCF
f 遞增 (Increment f)

|||
|---|---|
| 語法:          | \`INCF f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (f) + 1 → dest |
| 受影響狀態位元: | N, OV, Z |
| 編碼:          | 0000 10da ffff ffff |

**描述:** 暫存器 'f' 的內容遞增 1。如果 'd' 為 '0'，結果儲存在 W。如果 'd' 為 '1'，結果存回暫存器 'f' (預設值)。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入目的地 |

**範例:**
\`\`\`
INCF CNT, 1, 1
\`\`\`

指令執行前  
CNT = FFh  
指令執行後  
CNT = 00h`
    },
    {
        name: "INCFSZ",
        content: `#### INCFSZ
f 遞增，若為零則跳過 (Increment f, Skip if Zero)

|||
|---|---|
| 語法:          | \`INCFSZ f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (f) + 1 → dest, 若 (f) + 1 = 0 則跳過 |
| 受影響狀態位元: | 無 |
| 編碼:          | 0011 11da ffff ffff |

**描述:** 暫存器 'f' 的內容遞增 1。如果 'd' 為 '0'，結果儲存在 W。如果 'd' 為 '1'，結果存回暫存器 'f' (預設值)。如果結果為 0，則跳過下一條指令。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1(2)  
**注意:** 若跳過且後面是 2 字指令，則為 3 週期。

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入目的地 |

若跳過:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
(HERE) INCFSZ CNT, 1, 1  
CONT_A :  
CONT_B :  
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
若 CNT + 1 = 0; PC = 位址 (CONT_A)  
若 CNT + 1 ≠ 0; PC = 位址 (CONT_B)`
    },
    {
        name: "INFSNZ",
        content: `#### INFSNZ
f 遞增，若不為零則跳過 (Increment f, Skip if Not Zero)

|||
|---|---|
| 語法:          | \`INFSNZ f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (f) + 1 → dest, 若 (f) + 1 ≠ 0 則跳過 |
| 受影響狀態位元: | 無 |
| 編碼:          | 0011 10da ffff ffff |

**描述:** 暫存器 'f' 的內容遞增 1。如果 'd' 為 '0'，結果儲存在 W。如果 'd' 為 '1'，結果存回暫存器 'f' (預設值)。如果結果不為 0，則跳過下一條指令。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1(2)  
**注意:** 若跳過且後面是 2 字指令，則為 3 週期。

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入目的地 |

若跳過:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
(HERE) INFSNZ CNT, 1, 1  
CONT_A :  
CONT_B :  
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
若 CNT + 1 = 0; PC = 位址 (CONT_A)  
若 CNT + 1 ≠ 0; PC = 位址 (CONT_B)`
    },
    {
        name: "IORLW",
        content: `#### IORLW
將常數與 W 進行 OR 運算 (Inclusive OR Literal with W)

|||
|---|---|
| 語法:          | \`IORLW k\` |
| 運算元:        | 0 ≤ k ≤ 255 |
| 操作:          | (W) .OR. k → W |
| 受影響狀態位元: | N, Z |
| 編碼:          | 0000 1001 kkkk kkkk |

**描述:** W 的內容與 8 位元常數 'k' 進行 OR 運算。結果置於 W。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'k' | 處理資料 | 寫入 W |

**範例:**
\`\`\`
IORLW 35h
\`\`\`

指令執行前  
W = 9Ah  
指令執行後  
W = 0BFh`
    },
    {
        name: "IORWF",
        content: `#### IORWF
將 W 與 f 進行 OR 運算 (Inclusive OR W with f)

|||
|---|---|
| 語法:          | \`IORWF f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (W) .OR. (f) → dest |
| 受影響狀態位元: | N, Z |
| 編碼:          | 0001 00da ffff ffff |

**描述:** W 的內容與暫存器 "f" 進行 OR 運算。如果 'd' 為 '0'，結果儲存在 W。如果 'd' 為 '1'，結果存回暫存器 "f" (預設值)。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 "f" | 處理資料 | 寫入目的地 |

**範例:**
\`\`\`
IORWF RESULT, 0, 0
\`\`\`

指令執行前  
W = 17h  
RESULT = C2h  
指令執行後  
W = D7h  
RESULT = C2h`
    },
    {
        name: "LFSR",
        content: `#### LFSR
載入 FSR (Load FSR)

|||
|---|---|
| 語法:          | \`LFSR f, k\` |
| 運算元:        | f ∈ [0,2] 0 ≤ k ≤ 4095 |
| 操作:          | k → FSRf |
| 受影響狀態位元: | 無 |
| 編碼:          | 第 1 字: 1110 1110 00ff kkkk<br>第 2 字: kkkk kkkk kkkk kkkk |

**描述:** 將 12 位元常數 'k' 載入指定的 FSR (FSR0, FSR1, FSR2)。這是一個兩字指令。

**字數:** 2  
**週期數:** 2  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'k'<3:0> | 讀取常數 'k'<11:4>, 寫入 FSRf | 無操作 |
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
LFSR 0, 0x123
\`\`\`

指令執行前  
FSR0 = 000h  
指令執行後  
FSR0 = 123h`
    },
    {
        name: "MOVF",
        content: `#### MOVF
移動 f (Move f)

|||
|---|---|
| 語法:          | \`MOVF f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (f) → dest |
| 受影響狀態位元: | N, Z |
| 編碼:          | 0001 10da ffff ffff |

**描述:** 移動資料記憶體位置 'f' 的內容。如果 'd' 為 '0'，則 W 被載入資料記憶體位置 'f' 的內容。如果 'd' 為 '1'，則資料記憶體位置 'f' 被載入其自身的內容，這主要用於測試該位置的內容。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入目的地 |

**範例:**
\`\`\`
MOVF REG, 0, 0
\`\`\`

指令執行前  
W = ?  
REG = 0FFh  
指令執行後  
W = 0FFh  
REG = 0FFh`
    },
    {
        name: "MOVFF",
        content: `#### MOVFF
從 fs 移動到 fd (Move fs to fd)

|||
|---|---|
| 語法:          | \`MOVFF fs, fd\` |
| 運算元:        | 0 ≤ fs ≤ 4095 0 ≤ fd ≤ 4095 |
| 操作:          | (fs) → fd |
| 受影響狀態位元: | 無 |
| 編碼:          | 第 1 字: 1100 ffff ffff ffff<br>第 2 字: 1111 ffff ffff ffff |

**描述:** 將資料從來源暫存器 'fs' 移動到目的地暫存器 'fd'。來源和目的地暫存器可以位於資料記憶體中的任何位置。這是一個兩字指令。

**字數:** 2  
**週期數:** 2  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取來源 'fs' | 處理資料 | 寫入目的地 'fd' |
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
MOVFF REG1, REG2
\`\`\`

指令執行前  
REG1 = 0FFh  
REG2 = 01h  
指令執行後  
REG1 = 0FFh  
REG2 = 0FFh`
    },
    {
        name: "MOVLB",
        content: `#### MOVLB
將常數載入 BSR (Move Literal to BSR)

|||
|---|---|
| 語法:          | \`MOVLB k\` |
| 運算元:        | 0 ≤ k ≤ 15 |
| 操作:          | k → BSR<3:0> |
| 受影響狀態位元: | 無 |
| 編碼:          | 0000 0001 0000 kkkk |

**描述:** 將 4 位元常數 'k' 載入 BSR 的低 4 位元。BSR 的高位元被清除。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 無操作 | 處理資料 | 寫入 BSR |

**範例:**
\`\`\`
MOVLB 0x5
\`\`\`

指令執行前  
BSR = 00h  
指令執行後  
BSR = 05h`
    },
    {
        name: "MOVLW",
        content: `#### MOVLW
將常數載入 W (Move Literal to W)

|||
|---|---|
| 語法:          | \`MOVLW k\` |
| 運算元:        | 0 ≤ k ≤ 255 |
| 操作:          | k → W |
| 受影響狀態位元: | 無 |
| 編碼:          | 0000 1110 kkkk kkkk |

**描述:** 將 8 位元常數 'k' 載入 W 暫存器。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'k' | 處理資料 | 寫入 W |

**範例:**
\`\`\`
MOVLW 5Fh
\`\`\`

指令執行前  
W = 10h  
指令執行後  
W = 5Fh`
    },
    {
        name: "MOVWF",
        content: `#### MOVWF
將 W 移動到 f (Move W to f)

|||
|---|---|
| 語法:          | \`MOVWF f {,a}\` |
| 運算元:        | 0 ≤ f ≤ 255 a ∈ [0,1] |
| 操作:          | (W) → f |
| 受影響狀態位元: | 無 |
| 編碼:          | 0000 0000 1fff ffff |

**描述:** 將 W 暫存器的內容移動到資料記憶體位置 'f'。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入暫存器 'f' |

**範例:**
\`\`\`
MOVWF REG, 1
\`\`\`

指令執行前  
W = 4Fh  
REG = 0FFh  
指令執行後  
W = 4Fh  
REG = 4Fh`
    },
    {
        name: "MULLW",
        content: `#### MULLW
將常數與 W 相乘 (Multiply Literal with W)

|||
|---|---|
| 語法:          | \`MULLW k\` |
| 運算元:        | 0 ≤ k ≤ 255 |
| 操作:          | (W) x k → PRODH:PRODL |
| 受影響狀態位元: | 無 |
| 編碼:          | 0000 1101 kkkk kkkk |

**描述:** 這是一個 8x8 無符號乘法運算。W 暫存器的內容與常數 'k' 相乘。結果是一個 16 位元數字，儲存在 PRODH (高字節) 和 PRODL (低字節) 暫存器中。W 暫存器的內容保持不變。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'k' | 處理資料 | 寫入 PRODH, PRODL |

**範例:**
\`\`\`
MULLW 0C4h
\`\`\`

指令執行前  
W = A2h  
指令執行後  
W = A2h  
PRODH = 78h  
PRODL = 08h`
    },
    {
        name: "MULWF",
        content: `#### MULWF
將 W 與 f 相乘 (Multiply W with f)

|||
|---|---|
| 語法:          | \`MULWF f {,a}\` |
| 運算元:        | 0 ≤ f ≤ 255 a ∈ [0,1] |
| 操作:          | (W) x (f) → PRODH:PRODL |
| 受影響狀態位元: | 無 |
| 編碼:          | 0000 0000 0010 0000 |

**描述:** 這是一個 8x8 無符號乘法運算。W 暫存器的內容與資料記憶體位置 'f' 的內容相乘。結果是一個 16 位元數字，儲存在 PRODH (高字節) 和 PRODL (低字節) 暫存器中。W 暫存器和 'f' 的內容保持不變。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入 PRODH, PRODL |

**範例:**
\`\`\`
MULWF REG, 1
\`\`\`

指令執行前  
W = A2h  
REG = C4h  
指令執行後  
W = A2h  
REG = C4h  
PRODH = 78h  
PRODL = 08h`
    },
    {
        name: "NEGF",
        content: `#### NEGF
f 取負 (Negate f)

|||
|---|---|
| 語法:          | \`NEGF f {,a}\` |
| 運算元:        | 0 ≤ f ≤ 255 a ∈ [0,1] |
| 操作:          | -(f) → f |
| 受影響狀態位元: | N, OV, C, DC, Z |
| 編碼:          | 0110 110a ffff ffff |

**描述:** 資料記憶體位置 'f' 的內容被取負 (2 的補數)。結果儲存在 'f'。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入暫存器 'f' |

**範例:**
\`\`\`
NEGF REG, 1
\`\`\`

指令執行前  
REG = 02h  
指令執行後  
REG = 0FEh`
    },
    {
        name: "NOP",
        content: `#### NOP
無操作 (No Operation)

|||
|---|---|
| 語法:          | \`NOP\` |
| 運算元:        | 無 |
| 操作:          | 無操作 |
| 受影響狀態位元: | 無 |
| 編碼:          | 0000 0000 0000 0000 |

**描述:** 不執行任何操作。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
NOP
\`\`\``
    },
    {
        name: "POP",
        content: `#### POP
從堆疊彈出 (Pop from Stack)

|||
|---|---|
| 語法:          | \`POP\` |
| 運算元:        | 無 |
| 操作:          | (TOS) → 捨棄, (STKPTR) - 1 → STKPTR |
| 受影響狀態位元: | 無 |
| 編碼:          | 0000 0000 0000 0110 |

**描述:** 堆疊指標 (STKPTR) 遞減。頂部堆疊值 (TOS) 被丟棄。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 無操作 | 處理資料 | 寫入 STKPTR |

**範例:**
\`\`\`
POP
\`\`\`

指令執行前  
STKPTR = 0Fh  
指令執行後  
STKPTR = 0Eh`
    },
    {
        name: "PUSH",
        content: `#### PUSH
推入堆疊 (Push to Stack)

|||
|---|---|
| 語法:          | \`PUSH\` |
| 運算元:        | 無 |
| 操作:          | (PC) + 2 → TOS, (STKPTR) + 1 → STKPTR |
| 受影響狀態位元: | 無 |
| 編碼:          | 0000 0000 0000 0101 |

**描述:** PC + 2 被推入返回堆疊。堆疊指標 (STKPTR) 遞增。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 無操作 | 處理資料 | 寫入 TOS, STKPTR |

**範例:**
\`\`\`
PUSH
\`\`\`

指令執行前  
PC = 位址 (HERE)  
STKPTR = 0Fh  
指令執行後  
TOS = 位址 (HERE + 2)  
STKPTR = 10h`
    },
    {
        name: "RCALL",
        content: `#### RCALL
相對副程式呼叫 (Relative Call)

|||
|---|---|
| 語法:          | \`RCALL n\` |
| 運算元:        | -1024 ≤ n ≤ 1023 |
| 操作:          | (PC) + 2 → TOS, (PC) + 2 + 2n → PC |
| 受影響狀態位元: | 無 |
| 編碼:          | 1101 1nnn nnnn nnnn |

**描述:** 在目前程式記憶體頁面內進行副程式呼叫。首先，返回位址 (PC + 2) 被推入返回堆疊。然後，將 2 的補數 '2n' 加到 PC。由於 PC 會遞增以取得下一個指令，新位址將是 PC + 2 + 2n。RCALL 是一個兩週期指令。

**字數:** 1  
**週期數:** 2  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'n', 將 PC 推入堆疊 | 處理資料 | 寫入 PC |
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
(HERE) RCALL THERE
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
PC = 位址 (THERE)  
TOS = 位址 (HERE + 2)`
    },
    {
        name: "RESET",
        content: `#### RESET
軟體重設 (Software Reset)

|||
|---|---|
| 語法:          | \`RESET\` |
| 運算元:        | 無 |
| 操作:          | 所有暫存器重設為重設狀態 |
| 受影響狀態位元: | 全部 |
| 編碼:          | 0000 0000 1111 1111 |

**描述:** 觸發軟體重設。所有暫存器都會回到其重設狀態。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 無操作 | 處理資料 | 觸發重設 |

**範例:**
\`\`\`
RESET
\`\`\``
    },
    {
        name: "RETFIE",
        content: `#### RETFIE
從中斷返回 (Return from Interrupt)

|||
|---|---|
| 語法:          | \`RETFIE {,s}\` |
| 運算元:        | s ∈ [0,1] |
| 操作:          | (TOS) → PC, (STKPTR) - 1 → STKPTR; 若 s = 1, (WS) → W, (STATUSS) → STATUS, (BSRS) → BSR |
| 受影響狀態位元: | 全部 |
| 編碼:          | 0000 0000 0000 1001 |

**描述:** 從中斷返回。堆疊指標 (STKPTR) 遞減。頂部堆疊值 (TOS) 被載入程式計數器 (PC)。如果 's' = 1，則影子暫存器 WS、STATUSS 和 BSRS 的內容會被載入它們各自的工作暫存器 W、STATUS 和 BSR。如果 's' = 0，則不進行更新 (預設值)。

**字數:** 1  
**週期數:** 2  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 無操作 | 處理資料 | 寫入 PC, STKPTR |
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
RETFIE 1
\`\`\`

指令執行前  
PC = ?  
W = ?  
STATUS = ?  
BSR = ?  
指令執行後  
PC = TOS  
W = WS  
STATUS = STATUSS  
BSR = BSRS  
STKPTR = STKPTR - 1`
    },
    {
        name: "RETLW",
        content: `#### RETLW
將常數載入 W 並返回 (Return with Literal in W)

|||
|---|---|
| 語法:          | \`RETLW k\` |
| 運算元:        | 0 ≤ k ≤ 255 |
| 操作:          | k → W, (TOS) → PC, (STKPTR) - 1 → STKPTR |
| 受影響狀態位元: | 無 |
| 編碼:          | 0000 1100 kkkk kkkk |

**描述:** W 暫存器被載入 8 位元常數 'k'。程式計數器 (PC) 從頂部堆疊值 (TOS) 載入。堆疊指標 (STKPTR) 遞減。這是一個兩週期指令。

**字數:** 1  
**週期數:** 2  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'k' | 處理資料 | 寫入 W, PC, STKPTR |
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
RETLW 5Fh
\`\`\`

指令執行前  
W = 00h  
指令執行後  
W = 5Fh  
PC = TOS  
STKPTR = STKPTR - 1`
    },
    {
        name: "RETURN",
        content: `#### RETURN
從副程式返回 (Return from Subroutine)

|||
|---|---|
| 語法:          | \`RETURN {,s}\` |
| 運算元:        | s ∈ [0,1] |
| 操作:          | (TOS) → PC, (STKPTR) - 1 → STKPTR; 若 s = 1, (WS) → W, (STATUSS) → STATUS, (BSRS) → BSR |
| 受影響狀態位元: | 全部 |
| 編碼:          | 0000 0000 0000 1000 |

**描述:** 從副程式返回。堆疊指標 (STKPTR) 遞減。頂部堆疊值 (TOS) 被載入程式計數器 (PC)。如果 's' = 1，則影子暫存器 WS、STATUSS 和 BSRS 的內容會被載入它們各自的工作暫存器 W、STATUS 和 BSR。如果 's' = 0，則不進行更新 (預設值)。

**字數:** 1  
**週期數:** 2  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 無操作 | 處理資料 | 寫入 PC, STKPTR |
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
RETURN 1
\`\`\`

指令執行前  
PC = ?  
W = ?  
STATUS = ?  
BSR = ?  
指令執行後  
PC = TOS  
W = WS  
STATUS = STATUSS  
BSR = BSRS  
STKPTR = STKPTR - 1`
    },
    {
        name: "RLCF",
        content: `#### RLCF
f 連同進位左旋轉 (Rotate Left f through Carry)

|||
|---|---|
| 語法:          | \`RLCF f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (f<n>) → dest<n+1>, (f<7>) → C, (C) → dest<0> |
| 受影響狀態位元: | N, Z, C |
| 編碼:          | 0011 01da ffff ffff |

**描述:** 資料記憶體位置 'f' 的內容連同進位旗標 (Carry flag) 一起左旋轉一位。如果 'd' 為 '0'，結果儲存在 W。如果 'd' 為 '1'，結果存回資料記憶體位置 'f' (預設值)。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入目的地 |

**範例:**
\`\`\`
RLCF REG, 0, 0
\`\`\`

指令執行前  
進位 = 0  
REG = B5h [1011 0101]  
指令執行後  
進位 = 1  
W = 6Ah [0110 1010]  
REG = B5h`
    },
    {
        name: "RLNCF",
        content: `#### RLNCF
f 不連同進位左旋轉 (Rotate Left f (No Carry))

|||
|---|---|
| 語法:          | \`RLNCF f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (f<n>) → dest<n+1>, (f<7>) → dest<0> |
| 受影響狀態位元: | N, Z |
| 編碼:          | 0010 01da ffff ffff |

**描述:** 資料記憶體位置 'f' 的內容左旋轉一位。進位旗標不參與旋轉。如果 'd' 為 '0'，結果儲存在 W。如果 'd' 為 '1'，結果存回資料記憶體位置 'f' (預設值)。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入目的地 |

**範例:**
\`\`\`
RLNCF REG, 0, 0
\`\`\`

指令執行前  
REG = B5h [1011 0101]  
指令執行後  
W = 6Bh [0110 1011]  
REG = B5h`
    },
    {
        name: "RRCF",
        content: `#### RRCF
f 連同進位右旋轉 (Rotate Right f through Carry)

|||
|---|---|
| 語法:          | \`RRCF f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (f<n>) → dest<n-1>, (f<0>) → C, (C) → dest<7> |
| 受影響狀態位元: | N, Z, C |
| 編碼:          | 0011 00da ffff ffff |

**描述:** 資料記憶體位置 'f' 的內容連同進位旗標 (Carry flag) 一起右旋轉一位。如果 'd' 為 '0'，結果儲存在 W。如果 'd' 為 '1'，結果存回資料記憶體位置 'f' (預設值)。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入目的地 |

**範例:**
\`\`\`
RRCF REG, 0, 0
\`\`\`

指令執行前  
進位 = 0  
REG = B5h [1011 0101]  
指令執行後  
進位 = 1  
W = 5Ah [0101 1010]  
REG = B5h`
    },
    {
        name: "RRNCF",
        content: `#### RRNCF
f 不連同進位右旋轉 (Rotate Right f (No Carry))

|||
|---|---|
| 語法:          | \`RRNCF f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (f<n>) → dest<n-1>, (f<0>) → dest<7> |
| 受影響狀態位元: | N, Z |
| 編碼:          | 0010 00da ffff ffff |

**描述:** 資料記憶體位置 'f' 的內容右旋轉一位。進位旗標不參與旋轉。如果 'd' 為 '0'，結果儲存在 W。如果 'd' 為 '1'，結果存回資料記憶體位置 'f' (預設值)。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入目的地 |

**範例:**
\`\`\`
RRNCF REG, 0, 0
\`\`\`

指令執行前  
REG = B5h [1011 0101]  
指令執行後  
W = DAh [1101 1010]  
REG = B5h`
    },
    {
        name: "SETF",
        content: `#### SETF
設定 f (Set f)

|||
|---|---|
| 語法:          | \`SETF f {,a}\` |
| 運算元:        | 0 ≤ f ≤ 255 a ∈ [0,1] |
| 操作:          | 0FFh → f |
| 受影響狀態位元: | 無 |
| 編碼:          | 0110 111a ffff ffff |

**描述:** 將資料記憶體位置 'f' 的所有位元設定為 '1'。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入暫存器 'f' |

**範例:**
\`\`\`
SETF REG, 1
\`\`\`

指令執行前  
REG = 5Ah  
指令執行後  
REG = 0FFh`
    },
    {
        name: "SLEEP",
        content: `#### SLEEP
進入睡眠模式 (Enter Sleep mode)

|||
|---|---|
| 語法:          | \`SLEEP\` |
| 運算元:        | 無 |
| 操作:          | 00h → WDT, 0 → WDT 後分頻器, 1 → TO, 0 → PD |
| 受影響狀態位元: | TO, PD |
| 編碼:          | 0000 0000 0000 0011 |

**描述:** 電源下降狀態位元 (Power-down Status bit, PD) 被清除。逾時狀態位元 (Time-out Status bit, TO) 被設定。看門狗計時器 (WDT) 及其後分頻器被清除。振盪器停止運轉。處理器進入睡眠模式。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 無操作 | 處理資料 | 無操作 |

**範例:**
\`\`\`
SLEEP
\`\`\`

指令執行前  
WDT 計數器 = ?  
指令執行後  
WDT 計數器 = 00h  
WDT 後分頻器 = 0  
TO = 1  
PD = 0`
    },
    {
        name: "SUBFWB",
        content: `#### SUBFWB
從 f 減去 W 並借位 (Subtract W from f with Borrow)

|||
|---|---|
| 語法:          | \`SUBFWB f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (f) - (W) - (C) → dest |
| 受影響狀態位元: | N, OV, C, DC, Z |
| 編碼:          | 0110 101a ffff ffff |

**描述:** 從資料記憶體位置 "f" 中減去 W 暫存器和借位旗標 (Carry flag, 作為借位)。如果 'd' 為 '0'，結果置於 W。如果 'd' 為 '1'，結果置於資料記憶體位置 "f"。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 "f" | 處理資料 | 寫入目的地 |

**範例:**
\`\`\`
SUBFWB REG, 0, 1
\`\`\`

指令執行前  
借位 = 1  
REG = 03h  
W = 02h  
指令執行後  
借位 = 1  
REG = 03h  
W = 00h`
    },
    {
        name: "SUBWF",
        content: `#### SUBWF
從 f 減去 W (Subtract W from f)

|||
|---|---|
| 語法:          | \`SUBWF f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (f) - (W) → dest |
| 受影響狀態位元: | N, OV, C, DC, Z |
| 編碼:          | 0000 11da ffff ffff |

**描述:** 從資料記憶體位置 "f" 中減去 W 暫存器。如果 'd' 為 '0'，結果置於 W。如果 'd' 為 '1'，結果置於資料記憶體位置 "f"。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 "f" | 處理資料 | 寫入目的地 |

**範例:**
\`\`\`
SUBWF REG, 0, 0
\`\`\`

指令執行前  
REG = 03h  
W = 02h  
指令執行後  
REG = 03h  
W = 01h`
    },
    {
        name: "SUBWFB",
        content: `#### SUBWFB
從 W 減去 f 並借位 (Subtract f from W with Borrow)

|||
|---|---|
| 語法:          | \`SUBWFB f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (W) - (f) - (C) → dest |
| 受影響狀態位元: | N, OV, C, DC, Z |
| 編碼:          | 0110 100a ffff ffff |

**描述:** 從 W 暫存器中減去資料記憶體位置 "f" 和借位旗標 (Carry flag, 作為借位)。如果 'd' 為 '0'，結果置於 W。如果 'd' 為 '1'，結果置於資料記憶體位置 "f"。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 "f" | 處理資料 | 寫入目的地 |

**範例:**
\`\`\`
SUBWFB REG, 0, 1
\`\`\`

指令執行前  
借位 = 1  
REG = 02h  
W = 03h  
指令執行後  
借位 = 1  
REG = 02h  
W = 00h`
    },
    {
        name: "SWAPF",
        content: `#### SWAPF
交換 f 的半位元組 (Swap Nibbles in f)

|||
|---|---|
| 語法:          | \`SWAPF f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (f<3:0>) → dest<7:4>, (f<7:4>) → dest<3:0> |
| 受影響狀態位元: | 無 |
| 編碼:          | 0011 10da ffff ffff |

**描述:** 資料記憶體位置 'f' 的高半位元組 (高 4 位元) 和低半位元組 (低 4 位元) 交換位置。如果 'd' 為 '0'，結果儲存在 W。如果 'd' 為 '1'，結果存回資料記憶體位置 'f' (預設值)。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 寫入目的地 |

**範例:**
\`\`\`
SWAPF REG, 0, 0
\`\`\`

指令執行前  
REG = A5h  
指令執行後  
REG = A5h  
W = 5Ah`
    },
    {
        name: "TBLRD",
        content: `#### TBLRD
表格讀取 (Table Read)

|||
|---|---|
| 語法:          | \`TBLRD {*}\` |
| 運算元:        | * ∈ {*, *+, *-, +*}, 預設為 * |
| 操作:          | (程序記憶體[ TABLAT ]) → TABLAT, 更新 TABLAT |
| 受影響狀態位元: | 無 |
| 編碼:          | 0000 0000 0000 1011 |

**描述:** 從程式記憶體中讀取一個位元組到資料記憶體。表格位址由 TABLAT 暫存器提供。讀取的資料被載入 TABLAT 暫存器。表格位址指標可以根據使用的選項進行後遞增、後遞減或前遞增。

**字數:** 1  
**週期數:** 2 (內部程式記憶體), 3 (外部程式記憶體)

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取 TABLAT (位址) | 處理資料 | 寫入 TABLAT (資料) |
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
TBLRD*+
\`\`\`

指令執行前  
TABLAT = 地址 2000h  
指令執行後  
TABLAT = 地址 2000h 的內容  
TABLAT = TABLAT + 1`
    },
    {
        name: "TBLWT",
        content: `#### TBLWT
表格寫入 (Table Write)

|||
|---|---|
| 語法:          | \`TBLWT {*}\` |
| 運算元:        | * ∈ {*, *+, *-, +*}, 預設為 * |
| 操作:          | (TABLAT) → 程序記憶體[ TABLAT ], 更新 TABLAT |
| 受影響狀態位元: | 無 |
| 編碼:          | 0000 0000 0000 1010 |

**描述:** 將一個位元組從資料記憶體寫入程式記憶體。表格位址由 TABLAT 暫存器提供。TABLAT 暫存器的資料被寫入程式記憶體。表格位址指標可以根據使用的選項進行後遞增、後遞減或前遞增。

**字數:** 1  
**週期數:** 2 (內部程式記憶體), 3 (外部程式記憶體)

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取 TABLAT (位址) | 處理資料 | 寫入程式記憶體 |
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
TBLWT*+
\`\`\`

指令執行前  
TABLAT = 地址 2000h  
TABLAT = 資料  
指令執行後  
地址 2000h 的內容 = TABLAT  
TABLAT = TABLAT + 1`
    },
    {
        name: "TSTFSZ",
        content: `#### TSTFSZ
測試 f，若為零則跳過 (Test f, Skip if Zero)

|||
|---|---|
| 語法:          | \`TSTFSZ f {,a}\` |
| 運算元:        | 0 ≤ f ≤ 255 a ∈ [0,1] |
| 操作:          | (f) - 0, 若 (f) = 0 則跳過 |
| 受影響狀態位元: | 無 |
| 編碼:          | 0110 011a ffff ffff |

**描述:** 資料記憶體位置 'f' 的內容與 0 進行比較。如果 'f' = 0，則跳過下一條指令。如果 'f' = 0，則在當前指令執行期間取得的下一條指令將被丟棄，並改為執行 NOP，從而使此指令成為兩週期指令。

**字數:** 1  
**週期數:** 1(2)  
**注意:** 若跳過且後面是 2 字指令，則為 3 週期。

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 'f' | 處理資料 | 無操作 |

若跳過:

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 無操作 | 無操作 | 無操作 | 無操作 |

**範例:**
\`\`\`
(HERE) TSTFSZ REG, 1  
FALSE :  
TRUE :  
\`\`\`

指令執行前  
PC = 位址 (HERE)  
指令執行後  
若 REG = 0; PC = 位址 (TRUE)  
若 REG ≠ 0; PC = 位址 (FALSE)`
    },
    {
        name: "XORLW",
        content: `#### XORLW
將常數與 W 進行 XOR 運算 (Exclusive OR Literal with W)

|||
|---|---|
| 語法:          | \`XORLW k\` |
| 運算元:        | 0 ≤ k ≤ 255 |
| 操作:          | (W) .XOR. k → W |
| 受影響狀態位元: | N, Z |
| 編碼:          | 0000 1010 kkkk kkkk |

**描述:** W 的內容與 8 位元常數 'k' 進行 XOR 運算。結果置於 W。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取常數 'k' | 處理資料 | 寫入 W |

**範例:**
\`\`\`
XORLW 0AFh
\`\`\`

指令執行前  
W = 0B5h  
指令執行後  
W = 1Ah`
    },
    {
        name: "XORWF",
        content: `#### XORWF
將 W 與 f 進行 XOR 運算 (Exclusive OR W with f)

|||
|---|---|
| 語法:          | \`XORWF f {,d {,a}}\` |
| 運算元:        | 0 ≤ f ≤ 255 d ∈ [0,1] a ∈ [0,1] |
| 操作:          | (W) .XOR. (f) → dest |
| 受影響狀態位元: | N, Z |
| 編碼:          | 0001 11da ffff ffff |

**描述:** W 的內容與暫存器 "f" 進行 XOR 運算。如果 'd' 為 '0'，結果儲存在 W。如果 'd' 為 '1'，結果存回暫存器 "f" (預設值)。如果 'a' 為 '0'，則選擇 Access Bank。如果 'a' 為 '1'，則使用 BSR 選擇 GPR 儲存區 (預設值)。

**字數:** 1  
**週期數:** 1  

**Q 週期活動:**

| Q1 | Q2 | Q3 | Q4 |
|---|---|---|---|
| 解碼 | 讀取暫存器 "f" | 處理資料 | 寫入目的地 |

**範例:**
\`\`\`
XORWF RESULT, 0, 0
\`\`\`

指令執行前  
W = 17h  
RESULT = C2h  
指令執行後  
W = D5h  
RESULT = C2h`
    }
];

export const INSTRUCTION_DETAILS_MAP_TC: Map<InstructionKey, string> = new Map(INSTRUCTION_DETAILS_TC.map(
    detail => [detail.name, detail.content]
));